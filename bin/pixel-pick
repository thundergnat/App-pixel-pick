#!/usr/bin/env perl6

use Color::Names::XKCD;

my %c = Color::Names::XKCD.color-data;

my $version = v0.6;

# Control-C exit
signal(SIGINT).tap: { sleep .1; cleanup(); print "\n" xx 50, "\e[H\e[J"; exit(0) }

# Control-Z exit
signal(SIGTSTP).tap: { sleep .1; print "\r  \n"; cleanup(); exit(0) }

multi MAIN () {
    use X11::libxdo;
    my $xdo = Xdo.new;
    my ($lx, $ly) = 0, 0;
    loop {
        sleep .1;
        my ($x, $y, $) = $xdo.get-mouse-location;
        next if $lx == $x and $ly == $y;
        ($lx, $ly) = $x, $y;
        display $x, $y, |get-pixel($x, $y);
    }
}

my %*SUB-MAIN-OPTS = :named-anywhere;

multi MAIN (
    Int $x,    #= Integer x coordinate to pick
    Int $y,    #= Integer y coordinate to pick
    $q = False #= Boolean "quiet" mode, set truthy for decimal values, set to h for hex values
  ) {
    my ($red, $green, $blue) = get-pixel($x, $y);

    if $q {
        $q.lc eq 'h' ??
          ( printf "%02X:%02X:%02X\n", $red, $green, $blue ) !!
          ( printf "%03d:%03d:%03d\n", $red, $green, $blue );
    } else {
        display($x, $y, $red, $green, $blue);
        cleanup();
    }
    exit(0);
}

sub get-pixel ($x, $y) {

    # import is installed as part of MagickWand. Most Linuxes
    # already have it. If not, need to install libmagickwand

    my $xcolor =
      qqx/import -window root -crop 1x1+{$x-1 max 0}+{$y-2 max 0} -depth 8 txt:-/
      .comb(/<?after '#'><xdigit> ** 6/);

    |$xcolor.comb(2)».parse-base(16);
}

sub display ($x, $y, $r, $g, $b) {
    my $indent = '    ';
    print "\e[?25l\e[48;2;0;0;0m\e[38;2;255;255;255m\e[H\e[J";
    printf "{$indent}v$version | x: %4d y: $y\n", $x;
    printf "{$indent}  RGB: %03d:%03d:%03d \n{$indent}    HEX: %02X:%02X:%02X\n",
            $r, $g, $b, $r, $g, $b;
    print "\e[38;2;{$r};{$g};{$b}m{$indent}",
           ('█' x 20 xx 6).join("\n{$indent}"), "\n\n\e[38;2;255;255;255m";

    say 'Nearby (XKCD) named colors:';

    # Uses "sensitivity" scaling values from wikipedia:Color_difference to search
    # for "nearby" colors. Adjust $threshold to expand or reduce search space.
    # 60 seems like a reasonble tradeoff between "too-much" and "not-enough".

    my $threshold = 60;

    my @c =  %c.grep: {
        3 * abs($r - .value<rgb>[0]) < $threshold and
        4 * abs($g - .value<rgb>[1]) < $threshold and
        2 * abs($b - .value<rgb>[2]) < $threshold
    }
    for @c -> $c {
        my $fg = (sqrt(sum $c.value<rgb>[0]², $c.value<rgb>[1]², $c.value<rgb>[2]²) > 140)
        ?? [0,0,0] !! [255,255,255];
        say "\e[48;2;{$c.value<rgb>[0]};{$c.value<rgb>[1]};{$c.value<rgb>[2]}m" ~
            "\e[38;2;{$fg[0]};{$fg[1]};{$fg[2]}m" ~
            sprintf("   RGB: %03d:%03d:%03d - HEX: %02X:%02X:%02X - %-26s",
                    |$c.value<rgb>, |$c.value<rgb>, $c.value<name>) ~ "\e[0m";
    }
}

sub cleanup { print "\e[0m\e[?25h" }
